{"ast":null,"code":"var _jsxFileName = \"/Users/sofiaspagnoletti/Desktop/second_time_around/client/src/components/Webcam/index.js\";\nimport React from \"react\";\nimport Webcam from \"react-webcam\";\n\nclass WebcamCapture extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    this.setRef = webcam => {\n      this.webcam = webcam;\n    };\n\n    this.capture = () => {\n      const imageSrc = this.webcam.getScreenshot();\n    };\n\n    this.dataURItoBlob = dataURI => {\n      var binary = atob(dataURI.split(',')[1]);\n      var array = [];\n\n      for (var i = 0; i < binary.length; i++) {\n        array.push(binary.charCodeAt(i));\n      }\n\n      return new Blob([new Uint8Array(array)], {\n        type: 'image/jpeg'\n      });\n    };\n\n    this.uploadFile = e => {\n      const files = Array.from(e.target.files);\n      this.setState({\n        uploading: true\n      });\n      const formData = new FormData();\n      files.forEach((file, i) => {\n        formData.append(i, file);\n      }); //sends the img to server\n\n      fetch(\"http://localhost:3001/image-upload\", {\n        method: 'POST',\n        body: formData\n      }).then(res => res.json()).then(images => {\n        this.setState({\n          uploading: false,\n          url: images[0].url\n        });\n      });\n    };\n  }\n\n  render() {\n    const videoConstraints = {\n      width: 1280,\n      height: 720,\n      facingMode: \"user\"\n    };\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 22\n      },\n      __self: this\n    }, React.createElement(Webcam, {\n      audio: false,\n      height: 350,\n      ref: this.setRef,\n      screenshotFormat: \"image/jpeg\",\n      width: 350,\n      videoConstraints: videoConstraints,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 23\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      onClick: this.capture,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 31\n      },\n      __self: this\n    }, \"Capture photo\"));\n  }\n\n}\n\nexport default WebcamCapture; // import React, { Component } from 'react';\n// import PropTypes from 'prop-types';\n// function hasGetUserMedia() {\n//   return !!(\n//     (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)\n//     || navigator.webkitGetUserMedia\n//     || navigator.mozGetUserMedia\n//     || navigator.msGetUserMedia\n//   );\n// }\n// const constrainStringType = PropTypes.oneOfType([\n//   PropTypes.string,\n//   PropTypes.arrayOf(PropTypes.string),\n//   PropTypes.shape({\n//     exact: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n// ]);\n// const constrainBooleanType = PropTypes.oneOfType([\n//   PropTypes.shape({\n//     exact: PropTypes.bool,\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.bool,\n//   }),\n// ]);\n// const constrainLongType = PropTypes.oneOfType([\n//   PropTypes.number,\n//   PropTypes.shape({\n//     exact: PropTypes.number,\n//     ideal: PropTypes.number,\n//     min: PropTypes.number,\n//     max: PropTypes.number,\n//   }),\n// ]);\n// const constrainDoubleType = constrainLongType;\n// const audioConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   autoGainControl: constrainBooleanType,\n//   channelCount: constrainLongType,\n//   latency: constrainDoubleType,\n//   noiseSuppression: constrainBooleanType,\n//   sampleRate: constrainLongType,\n//   sampleSize: constrainLongType,\n//   volume: constrainDoubleType,\n// });\n// const videoConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   aspectRatio: constrainDoubleType,\n//   facingMode: constrainStringType,\n//   frameRate: constrainDoubleType,\n//   height: constrainLongType,\n//   width: constrainLongType,\n// });\n// export default class Webcam extends Component {\n//   static defaultProps = {\n//     audio: true,\n//     className: '',\n//     height: 480,\n//     imageSmoothing: true,\n//     onUserMedia: () => {},\n//     onUserMediaError: () => {},\n//     screenshotFormat: 'image/webp',\n//     width: 640,\n//     screenshotQuality: 0.92,\n//   };\n//   static propTypes = {\n//     audio: PropTypes.bool,\n//     onUserMedia: PropTypes.func,\n//     onUserMediaError: PropTypes.func,\n//     height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n//     width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n//     screenshotFormat: PropTypes.oneOf([\n//       'image/webp',\n//       'image/png',\n//       'image/jpeg',\n//     ]),\n//     style: PropTypes.object,\n//     className: PropTypes.string,\n//     screenshotQuality: PropTypes.number,\n//     minScreenshotWidth: PropTypes.number,\n//     minScreenshotHeight: PropTypes.number,\n//     audioConstraints: audioConstraintType,\n//     videoConstraints: videoConstraintType,\n//     imageSmoothing: PropTypes.bool,\n//   };\n//   static mountedInstances = [];\n//   static userMediaRequested = false;\n//   constructor() {\n//     super();\n//     this.state = {\n//       hasUserMedia: false,\n//     };\n//   }\n//   componentDidMount() {\n//     if (!hasGetUserMedia()) return;\n//     const { state } = this;\n//     Webcam.mountedInstances.push(this);\n//     if (!state.hasUserMedia && !Webcam.userMediaRequested) {\n//       this.requestUserMedia();\n//     }\n//   }\n//   componentDidUpdate(nextProps) {\n//     const { props } = this;\n//     if (\n//       JSON.stringify(nextProps.audioConstraints)\n//         !== JSON.stringify(props.audioConstraints)\n//       || JSON.stringify(nextProps.videoConstraints)\n//         !== JSON.stringify(props.videoConstraints)\n//     ) {\n//       this.requestUserMedia();\n//     }\n//   }\n//   componentWillUnmount() {\n//     const { state } = this;\n//     const index = Webcam.mountedInstances.indexOf(this);\n//     Webcam.mountedInstances.splice(index, 1);\n//     Webcam.userMediaRequested = false;\n//     if (Webcam.mountedInstances.length === 0 && state.hasUserMedia) {\n//       if (this.stream.getVideoTracks && this.stream.getAudioTracks) {\n//         this.stream.getVideoTracks().map(track => track.stop());\n//         this.stream.getAudioTracks().map(track => track.stop());\n//       } else {\n//         this.stream.stop();\n//       }\n//       window.URL.revokeObjectURL(state.src);\n//     }\n//   }\n//   getScreenshot() {\n//     const { state, props } = this;\n//     if (!state.hasUserMedia) return null;\n//     const canvas = this.getCanvas();\n//     return (\n//       canvas\n//       && canvas.toDataURL(\n//         props.screenshotFormat,\n//         props.screenshotQuality,\n//       )\n//     );\n//   }\n//   getCanvas() {\n//     const { state, props } = this;\n//     if (!state.hasUserMedia || !this.video.videoHeight) return null;\n//     if (!this.ctx) {\n//       const canvas = document.createElement('canvas');\n//       const aspectRatio = this.video.videoWidth / this.video.videoHeight;\n//       let canvasWidth = props.minScreenshotWidth || this.video.clientWidth;\n//       let canvasHeight = canvasWidth / aspectRatio;\n//       if (props.minScreenshotHeight && (canvasHeight < props.minScreenshotHeight)) {\n//         canvasHeight = props.minScreenshotHeight;\n//         canvasWidth = canvasHeight * aspectRatio;\n//       }\n//       canvas.width = canvasWidth;\n//       canvas.height = canvasHeight;\n//       this.canvas = canvas;\n//       this.ctx = canvas.getContext('2d');\n//     }\n//     const { ctx, canvas } = this;\n//     ctx.imageSmoothingEnabled = props.imageSmoothing;\n//     ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);\n//     return canvas;\n//   }\n//   requestUserMedia() {\n//     const { props } = this;\n//     navigator.getUserMedia = navigator.mediaDevices.getUserMedia\n//       || navigator.webkitGetUserMedia\n//       || navigator.mozGetUserMedia\n//       || navigator.msGetUserMedia;\n//     const sourceSelected = (audioConstraints, videoConstraints) => {\n//       const constraints = {\n//         video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n//       };\n//       if (props.audio) {\n//         constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n//       }\n//       navigator.mediaDevices\n//         .getUserMedia(constraints)\n//         .then((stream) => {\n//           Webcam.mountedInstances.forEach(instance => instance.handleUserMedia(null, stream));\n//         })\n//         .catch((e) => {\n//           Webcam.mountedInstances.forEach(instance => instance.handleUserMedia(e));\n//         });\n//     };\n//     if ('mediaDevices' in navigator) {\n//       sourceSelected(props.audioConstraints, props.videoConstraints);\n//     } else {\n//       const optionalSource = id => ({ optional: [{ sourceId: id }] });\n//       const constraintToSourceId = (constraint) => {\n//         const { deviceId } = constraint || {};\n//         if (typeof deviceId === 'string') {\n//           return deviceId;\n//         }\n//         if (Array.isArray(deviceId) && deviceId.length > 0) {\n//           return deviceId[0];\n//         }\n//         if (typeof deviceId === 'object' && deviceId.ideal) {\n//           return deviceId.ideal;\n//         }\n//         return null;\n//       };\n//       MediaStreamTrack.getSources((sources) => {\n//         let audioSource = null;\n//         let videoSource = null;\n//         sources.forEach((source) => {\n//           if (source.kind === 'audio') {\n//             audioSource = source.id;\n//           } else if (source.kind === 'video') {\n//             videoSource = source.id;\n//           }\n//         });\n//         const audioSourceId = constraintToSourceId(props.audioConstraints);\n//         if (audioSourceId) {\n//           audioSource = audioSourceId;\n//         }\n//         const videoSourceId = constraintToSourceId(props.videoConstraints);\n//         if (videoSourceId) {\n//           videoSource = videoSourceId;\n//         }\n//         sourceSelected(\n//           optionalSource(audioSource),\n//           optionalSource(videoSource),\n//         );\n//       });\n//     }\n//     Webcam.userMediaRequested = true;\n//   }\n//   handleUserMedia(err, stream) {\n//     const { props } = this;\n//     if (err) {\n//       this.setState({ hasUserMedia: false });\n//       props.onUserMediaError(err);\n//       return;\n//     }\n//     this.stream = stream;\n//     try {\n//       this.video.srcObject = stream;\n//       this.setState({ hasUserMedia: true });\n//     } catch (error) {\n//       this.setState({\n//         hasUserMedia: true,\n//         src: window.URL.createObjectURL(stream),\n//       });\n//     }\n//     props.onUserMedia();\n//   }\n//   render() {\n//     const { state, props } = this;\n//     return (\n//       <video\n//         autoPlay\n//         width={props.width}\n//         height={props.height}\n//         src={state.src}\n//         muted={props.audio}\n//         className={props.className}\n//         playsInline\n//         style={props.style}\n//         ref={(ref) => {\n//           this.video = ref;\n//         }}\n//       />\n//     );\n//   }\n// }","map":{"version":3,"sources":["/Users/sofiaspagnoletti/Desktop/second_time_around/client/src/components/Webcam/index.js"],"names":["React","Webcam","WebcamCapture","Component","setRef","webcam","capture","imageSrc","getScreenshot","dataURItoBlob","dataURI","binary","atob","split","array","i","length","push","charCodeAt","Blob","Uint8Array","type","uploadFile","e","files","Array","from","target","setState","uploading","formData","FormData","forEach","file","append","fetch","method","body","then","res","json","images","url","render","videoConstraints","width","height","facingMode"],"mappings":"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A;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import React from \"react\";\nimport Webcam from \"react-webcam\";\n \n\nclass WebcamCapture extends React.Component {\n  setRef = webcam => {\n    this.webcam = webcam;\n  };\n \n  capture = () => {\n    const imageSrc = this.webcam.getScreenshot();\n  };\n \n  render() {\n    const videoConstraints = {\n      width: 1280,\n      height: 720,\n      facingMode: \"user\"\n    };\n \n    return (\n      <div>\n        <Webcam\n          audio={false}\n          height={350}\n          ref={this.setRef}\n          screenshotFormat=\"image/jpeg\"\n          width={350}\n          videoConstraints={videoConstraints}\n        />\n        <button onClick={this.capture}>Capture photo</button>\n      </div>\n    );\n  }\n  \n  dataURItoBlob = dataURI => {\n    var binary = atob(dataURI.split(',')[1]);\n    var array = [];\n    for(var i = 0; i < binary.length; i++) {\n        array.push(binary.charCodeAt(i));\n    }\n    return new Blob([new Uint8Array(array)], {type: 'image/jpeg'});\n}\n\n  uploadFile = e => {\n    const files = Array.from(e.target.files)\n    this.setState({ uploading: true })\n\n    const formData = new FormData()\n\n    files.forEach((file, i) => {\n      formData.append(i, file)\n    })\n\n    //sends the img to server\n    fetch(`http://localhost:3001/image-upload`, {\n      method: 'POST',\n      body: formData\n    })\n      .then(res => res.json())\n      .then(images => {\n        this.setState({\n          uploading: false,\n          url: images[0].url\n        });\n      });\n  }\n}\n\nexport default WebcamCapture;\n\n// import React, { Component } from 'react';\n// import PropTypes from 'prop-types';\n\n// function hasGetUserMedia() {\n//   return !!(\n//     (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)\n//     || navigator.webkitGetUserMedia\n//     || navigator.mozGetUserMedia\n//     || navigator.msGetUserMedia\n//   );\n// }\n\n// const constrainStringType = PropTypes.oneOfType([\n//   PropTypes.string,\n//   PropTypes.arrayOf(PropTypes.string),\n//   PropTypes.shape({\n//     exact: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n// ]);\n\n// const constrainBooleanType = PropTypes.oneOfType([\n//   PropTypes.shape({\n//     exact: PropTypes.bool,\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.bool,\n//   }),\n// ]);\n\n// const constrainLongType = PropTypes.oneOfType([\n//   PropTypes.number,\n//   PropTypes.shape({\n//     exact: PropTypes.number,\n//     ideal: PropTypes.number,\n//     min: PropTypes.number,\n//     max: PropTypes.number,\n//   }),\n// ]);\n\n// const constrainDoubleType = constrainLongType;\n\n// const audioConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   autoGainControl: constrainBooleanType,\n//   channelCount: constrainLongType,\n//   latency: constrainDoubleType,\n//   noiseSuppression: constrainBooleanType,\n//   sampleRate: constrainLongType,\n//   sampleSize: constrainLongType,\n//   volume: constrainDoubleType,\n// });\n\n// const videoConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   aspectRatio: constrainDoubleType,\n//   facingMode: constrainStringType,\n//   frameRate: constrainDoubleType,\n//   height: constrainLongType,\n//   width: constrainLongType,\n// });\n\n// export default class Webcam extends Component {\n//   static defaultProps = {\n//     audio: true,\n//     className: '',\n//     height: 480,\n//     imageSmoothing: true,\n//     onUserMedia: () => {},\n//     onUserMediaError: () => {},\n//     screenshotFormat: 'image/webp',\n//     width: 640,\n//     screenshotQuality: 0.92,\n//   };\n\n//   static propTypes = {\n//     audio: PropTypes.bool,\n//     onUserMedia: PropTypes.func,\n//     onUserMediaError: PropTypes.func,\n//     height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n//     width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n//     screenshotFormat: PropTypes.oneOf([\n//       'image/webp',\n//       'image/png',\n//       'image/jpeg',\n//     ]),\n//     style: PropTypes.object,\n//     className: PropTypes.string,\n//     screenshotQuality: PropTypes.number,\n//     minScreenshotWidth: PropTypes.number,\n//     minScreenshotHeight: PropTypes.number,\n//     audioConstraints: audioConstraintType,\n//     videoConstraints: videoConstraintType,\n//     imageSmoothing: PropTypes.bool,\n//   };\n\n//   static mountedInstances = [];\n\n//   static userMediaRequested = false;\n\n//   constructor() {\n//     super();\n//     this.state = {\n//       hasUserMedia: false,\n//     };\n//   }\n\n//   componentDidMount() {\n//     if (!hasGetUserMedia()) return;\n\n//     const { state } = this;\n\n//     Webcam.mountedInstances.push(this);\n\n//     if (!state.hasUserMedia && !Webcam.userMediaRequested) {\n//       this.requestUserMedia();\n//     }\n//   }\n\n//   componentDidUpdate(nextProps) {\n//     const { props } = this;\n//     if (\n//       JSON.stringify(nextProps.audioConstraints)\n//         !== JSON.stringify(props.audioConstraints)\n//       || JSON.stringify(nextProps.videoConstraints)\n//         !== JSON.stringify(props.videoConstraints)\n//     ) {\n//       this.requestUserMedia();\n//     }\n//   }\n\n//   componentWillUnmount() {\n//     const { state } = this;\n//     const index = Webcam.mountedInstances.indexOf(this);\n//     Webcam.mountedInstances.splice(index, 1);\n\n//     Webcam.userMediaRequested = false;\n//     if (Webcam.mountedInstances.length === 0 && state.hasUserMedia) {\n//       if (this.stream.getVideoTracks && this.stream.getAudioTracks) {\n//         this.stream.getVideoTracks().map(track => track.stop());\n//         this.stream.getAudioTracks().map(track => track.stop());\n//       } else {\n//         this.stream.stop();\n//       }\n//       window.URL.revokeObjectURL(state.src);\n//     }\n//   }\n\n//   getScreenshot() {\n//     const { state, props } = this;\n\n//     if (!state.hasUserMedia) return null;\n\n//     const canvas = this.getCanvas();\n//     return (\n//       canvas\n//       && canvas.toDataURL(\n//         props.screenshotFormat,\n//         props.screenshotQuality,\n//       )\n//     );\n//   }\n\n//   getCanvas() {\n//     const { state, props } = this;\n\n//     if (!state.hasUserMedia || !this.video.videoHeight) return null;\n\n//     if (!this.ctx) {\n//       const canvas = document.createElement('canvas');\n//       const aspectRatio = this.video.videoWidth / this.video.videoHeight;\n\n//       let canvasWidth = props.minScreenshotWidth || this.video.clientWidth;\n//       let canvasHeight = canvasWidth / aspectRatio;\n\n//       if (props.minScreenshotHeight && (canvasHeight < props.minScreenshotHeight)) {\n//         canvasHeight = props.minScreenshotHeight;\n//         canvasWidth = canvasHeight * aspectRatio;\n//       }\n\n//       canvas.width = canvasWidth;\n//       canvas.height = canvasHeight;\n\n//       this.canvas = canvas;\n//       this.ctx = canvas.getContext('2d');\n//     }\n\n//     const { ctx, canvas } = this;\n//     ctx.imageSmoothingEnabled = props.imageSmoothing;\n//     ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);\n\n//     return canvas;\n//   }\n\n//   requestUserMedia() {\n//     const { props } = this;\n\n//     navigator.getUserMedia = navigator.mediaDevices.getUserMedia\n//       || navigator.webkitGetUserMedia\n//       || navigator.mozGetUserMedia\n//       || navigator.msGetUserMedia;\n\n//     const sourceSelected = (audioConstraints, videoConstraints) => {\n//       const constraints = {\n//         video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n//       };\n\n//       if (props.audio) {\n//         constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n//       }\n\n//       navigator.mediaDevices\n//         .getUserMedia(constraints)\n//         .then((stream) => {\n//           Webcam.mountedInstances.forEach(instance => instance.handleUserMedia(null, stream));\n//         })\n//         .catch((e) => {\n//           Webcam.mountedInstances.forEach(instance => instance.handleUserMedia(e));\n//         });\n//     };\n\n//     if ('mediaDevices' in navigator) {\n//       sourceSelected(props.audioConstraints, props.videoConstraints);\n//     } else {\n//       const optionalSource = id => ({ optional: [{ sourceId: id }] });\n\n//       const constraintToSourceId = (constraint) => {\n//         const { deviceId } = constraint || {};\n\n//         if (typeof deviceId === 'string') {\n//           return deviceId;\n//         }\n\n//         if (Array.isArray(deviceId) && deviceId.length > 0) {\n//           return deviceId[0];\n//         }\n\n//         if (typeof deviceId === 'object' && deviceId.ideal) {\n//           return deviceId.ideal;\n//         }\n\n//         return null;\n//       };\n\n//       MediaStreamTrack.getSources((sources) => {\n//         let audioSource = null;\n//         let videoSource = null;\n\n//         sources.forEach((source) => {\n//           if (source.kind === 'audio') {\n//             audioSource = source.id;\n//           } else if (source.kind === 'video') {\n//             videoSource = source.id;\n//           }\n//         });\n\n//         const audioSourceId = constraintToSourceId(props.audioConstraints);\n//         if (audioSourceId) {\n//           audioSource = audioSourceId;\n//         }\n\n//         const videoSourceId = constraintToSourceId(props.videoConstraints);\n//         if (videoSourceId) {\n//           videoSource = videoSourceId;\n//         }\n\n//         sourceSelected(\n//           optionalSource(audioSource),\n//           optionalSource(videoSource),\n//         );\n//       });\n//     }\n\n//     Webcam.userMediaRequested = true;\n//   }\n\n//   handleUserMedia(err, stream) {\n//     const { props } = this;\n\n//     if (err) {\n//       this.setState({ hasUserMedia: false });\n//       props.onUserMediaError(err);\n\n//       return;\n//     }\n\n//     this.stream = stream;\n\n//     try {\n//       this.video.srcObject = stream;\n//       this.setState({ hasUserMedia: true });\n//     } catch (error) {\n//       this.setState({\n//         hasUserMedia: true,\n//         src: window.URL.createObjectURL(stream),\n//       });\n//     }\n\n//     props.onUserMedia();\n//   }\n\n//   render() {\n//     const { state, props } = this;\n\n//     return (\n//       <video\n//         autoPlay\n//         width={props.width}\n//         height={props.height}\n//         src={state.src}\n//         muted={props.audio}\n//         className={props.className}\n//         playsInline\n//         style={props.style}\n//         ref={(ref) => {\n//           this.video = ref;\n//         }}\n//       />\n//     );\n//   }\n// }"]},"metadata":{},"sourceType":"module"}